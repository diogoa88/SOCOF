package pl5;

import java.util.concurrent.atomic.AtomicReference;

public class LockFreeQueue<T> {

	public AtomicReference<Node<T>> head;
	public AtomicReference<Node<T>> tail;

	public LockFreeQueue() {
		Node<T> sentinel = new Node<T>(null);
		head = new AtomicReference<Node<T>>(sentinel);
		tail = new AtomicReference<Node<T>>(sentinel);
	}

	public void push(Node<T> newNode) {
		Node<T>oldTail;
		while(true) {
			oldTail = this.tail.get();
			if(oldTail.next.compareAndSet(null, newNode)) {
				if(tail.compareAndSet(, newValue))
			}
			newHead.next = new AtomicReference<Node<T>>(newNode);
			this.tail = new AtomicReference<Node<T>>(newNode);
		}

	}

	public Node<T> pop() {
		Node<T> nodeToRemove = this.head.get();
		Node<T> nextNode = nodeToRemove.next.get();
		this.head = new AtomicReference<Node<T>>(nextNode);
		return nodeToRemove;
	}

	public void print() {
		String res = "";
		Node<T> node = this.head.get();
		while (node != null) {
			node = node.next.get();
			if (node != null)
				res += node.value.toString() + " ";
		}
		System.out.println(res);
	}
	
	public void x() {
		oltTail = tail.get();
		newNode = new Node<Integer>(Value);
		if(oldTail.next.CompareSet(null, newNode)) {
			if(tail.compareAndSet(oldTail, newNode)) {
				return;
			}
		}
	}
}
